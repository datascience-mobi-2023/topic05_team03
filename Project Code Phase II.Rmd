---
title: "PhaseII"
output: html_document
date: "2023-05-24"
---
```{r}

```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
```{r}
prism
```
```{r}
liver_cancer_cell_lines
```
```{r}
which(rownames(prism.exp) %in% liver_cancer_cell_lines[1] )
```
```{r}
rownames(prism.exp)[467]
```
```{r}
prism.exp[467,]
```
```{r}
which(colnames(prism.exp) == "TP53")
#prism.exp[,8010]
prism.exp[467,8010]
mean(prism.exp[,8010], na.rm=TRUE)
```
```{r}
which(colnames(prism.exp) == "GAPDH") #housekeeping gene!
#prism.exp[,8010]
#prism.exp[467,8010]
#BUB1B, CCNB1, CDK1, CDC25C, CCNA2
```
```{r}
prism.exp[467,3878]
```
```{r}
mean(prism.exp[,3878], na.rm=TRUE)
```
```{r}
which(colnames(prism.exp) == "CDK1")
```
```{r}
prism.exp[467,12537]
mean(prism.exp[,12537], na.rm=TRUE)
```
```{r}
which(new_prism.treat$target == "CCNA2")
#This is the drug that targets the liver cancer relevant gene CCNA2
#concentration?
```
```{r}
#What's its name?
rownames(new_prism.treat[5521,])
```
```{r}
#in prism:
which(colnames(prism) == "BRD-K40331046-305-01-5::0.00061034::HTS002")
```
```{r}
prism[467, 5521]
```
```{r}
prism[467, 5521:5528]
```
```{r}
new_prism.treat[5521:5528,]
```

```{r}
Probetabelle = data.frame(new_prism.treat$target[5521:5528], rownames(new_prism.treat[5521:5528]))
```

```{r}
#now we've set the rownames of the prism.cl dataframe (a copy of it) to match the cell line identificators
#rownames(copy_prism.cl) = prism.cl[,1]
#copy_prism.cl
copy_achilles = prism.achilles
```
```{r}
order_actual_achilles = rownames (copy_achilles)
order_target_achilles = rownames(prism)
new_prism.achilles= copy_achilles[match(order_target_achilles, order_actual_achilles),]
new_prism.achilles
```
```{r}
liver_cancer_cell_lines
```
```{r}
#Which mutations do liver cancer cell lines have?
#prism.snv$DepMap_ID[which(prism.snv$DepMap_ID == liver_cancer_cell_lines)]
liver_cancer_cell_lines_mutations = prism.snv[which(prism.snv$DepMap_ID == liver_cancer_cell_lines),]

```
```{r}
#length(unique(liver_cancer_cell_lines_mutations$DepMap_ID))
#ok, they are 17, all good
```
```{r}
#goal: see if the mutation show any effect on gene expression
#1. count the total mutations for each cell line and compare with the expression scores

liver_cancer_cell_lines_total_mutation_numbers=c()
for (i in 1:length(liver_cancer_cell_lines))
{

 liver_cancer_cell_lines_total_mutation_numbers[i] =(length(which(liver_cancer_cell_lines_mutations == liver_cancer_cell_lines[i])))
  
}
names(liver_cancer_cell_lines_total_mutation_numbers) = liver_cancer_cell_lines
liver_cancer_cell_lines_total_mutation_numbers
```

```{r}
#re-order prism.exp so that it matches the prism data frame order
copy_prism.exp = prism.exp
order_actual_exp = rownames (copy_prism.exp)
order_target_exp = rownames(prism)
new_prism.exp= copy_prism.exp[match(order_target_exp, order_actual_exp),]
new_prism.exp
```
```{r}
#2. Now let's get the gene expression rates for these liver cancer cell lines
indeces_liver_cancer_cell_lines_in_new_prism.exp = c()
for (i in 1:length(liver_cancer_cell_lines))
{

   indeces_liver_cancer_cell_lines_in_new_prism.exp[i] = which(rownames(new_prism.exp) == liver_cancer_cell_lines[i])
  
}
liver_cancer_cell_lines_expression = new_prism.exp[indeces_liver_cancer_cell_lines_in_new_prism.exp,]
liver_cancer_cell_lines_expression
```

```{r}
#Let's see if there are genes which could bear mutations
```

```{r}
#all mutations of the first liver cancer cell line
liver_cancer_cell_lines_mutations[1:liver_cancer_cell_lines_total_mutation_numbers[1],]
```
```{r}
#I want to plot each gene of the cell line against its expression score
# x-axis = total mutation numbers
# y-axis =gene expression score
# points = genes


#od lass einf 1 plot machen mit expression of jede mutation
#x = liver_cancer_cell_lines_total_mutation_numbers#nein weil wir wollen eine mutation von einem gen in einer zelllinie
x = liver_cancer_cell_lines_mutations[1:liver_cancer_cell_lines_total_mutation_numbers[1],]$Hugo_Symbol
y = liver_cancer_cell_lines_expression[1,which(colnames(liver_cancer_cell_lines_expression)==x)]
plot(x,y)
```
```{r}
x = liver_cancer_cell_lines_mutations[1:liver_cancer_cell_lines_total_mutation_numbers[1],]$Hugo_Symbol
#which(colnames(liver_cancer_cell_lines_expression)==x)
x
colnames(liver_cancer_cell_lines_expression)
which(colnames(liver_cancer_cell_lines_expression)==x)
```
```{r}
indecesblabla=c()
for ( i in 1:length(x))
{
 indecesblabla[i] = which(colnames(liver_cancer_cell_lines_expression)==x[i])
  
}
#get expression of those genes
#plot against genes
```
```{r}
#PCA analysis on liver cancer cell lines - expression
pca = prcomp(liver_cancer_cell_lines_expression)
pca

```
```{r}
#pca2 = princomp(t(liver_cancer_cell_lines_expression))
#pca2
mean(cor(t(liver_cancer_cell_lines_expression)))
pca2$loadings
```

```{r}
pca.var = pca$sdev^2
pca.var.per = round(pca.var/sum(pca.var)*100,1)
pca.var.per
```
```{r}
barplot(pca.var.per, main= "Scree Plot", xlab="Principal Component", ylab="Percent Variation")
```

```{r}
plot(pca$x[,1], pca$x[,2])
```
```{r}
#install.packages("ggplot2")
#library(ggplot2)

```

```{r}
pca.data = data.frame(Sample=rownames(pca$x), X=pca$x[,1], Y=pca$x[,2])
pca.data
```
```{r}
ggplot(data = pca.data, aes(x=X, y=Y, label=Sample)) + geom_text() + xlab(paste("PC1-", pca.var.per[1], "%", sep="")) + ylab(paste("PC2- ", pca.var.per[2], "%", sep="")) + theme_bw() + ggtitle("My PCA Graph")
```
```{r}
loading_scores = pca$rotation[,1]
genes_scores = abs(loading_scores)
genes_scores_ranked = sort(genes_scores, decreasing = TRUE)
top_10_genes = names(genes_scores_ranked[1:10])
top_10_genes
pca$rotation[top_10_genes,1]
```
```{r}
correlation_matrix = cor(liver_cancer_cell_lines_expression)
head(correlation_matrix)
```

```{r}
pca analysis on expression x KO
```
```{r}
#First order them so genes match
which(colnames(new_prism.exp) %in% colnames(new_prism.achilles))
```
```{r}
#now we've set the rownames of the prism.cl dataframe (a copy of it) to match the cell line identificators
#rownames(copy_prism.cl) = prism.cl[,1]
#copy_prism.cl
copy_exp = prism.exp
order_actual_expr = colnames (copy_exp)
order_target_expr = colnames(prism.achilles)
new_prism.exp_x_ach= copy_exp[match(order_target_expr, order_actual_expr),]
new_prism.exp_x_ach
#someohow doesn't work, nevermind
```

```{r}
#let's correlate the cell lines expression with their achilles score
gene=colnames(new_prism.achilles)
for (j in 1:length(gene))
{
  print(cor(new_prism.achilles[gene[j]],new_prism.exp[gene[j]]))
}
  

```
```{r}
gene=colnames(new_prism.achilles)
new_prism.achilles[,gene[1]]
```
```{r}
new_prism.exp[,gene[1]]
```
```{r}
cor(new_prism.achilles[,gene[1]], new_prism.exp[,gene[1]])
```
```{r}
#ok, let's replace the NA values with the mean of the data sets
which(is.na(new_prism.achilles[,gene[1]]))
mean(new_prism.achilles[,gene[1]], na.rm=TRUE)
new_prism.achilles_wona= new_prism.achilles
new_prism.achilles_wona[,gene[1]][which(is.na(new_prism.achilles[,gene[1]]))] = mean(new_prism.achilles[,gene[1]], na.rm=TRUE)
```
```{r}
#now for exp
new_prism.exp_wona= new_prism.exp
new_prism.exp_wona[,gene[1]][which(is.na(new_prism.exp[,gene[1]]))] = mean(new_prism.exp[,gene[1]], na.rm=TRUE)
```
```{r}
#now let's perform the correlation
cor(new_prism.achilles_wona[,gene[1]], new_prism.exp_wona[,gene[1]])
for (i in 1:length(gene))
{
  #cor(new_prism.achilles_wona[,gene[i]], new_prism.exp_wona[,gene[i]])
  print(gene[i])
}
  
  cor(new_prism.achilles_wona[,gene[i]], new_prism.exp_wona[,gene[i]])
#cor(new_prism.achilles_wona[,gene], new_prism.exp_wona[,gene])

```

```{r}
for (i in 1:length(gene))
  {if( is.na(gene[i]) == TRUE)
    {print(gene[i])}
#else
   #{ print("totul ok")}
}
sum(is.na(gene))
```
```{r}
sum(is.na(gene))
length(gene) - sum(colnames(new_prism.achilles) %in% colnames(new_prism.exp)) #so 352 gene from achilles are not in prism.exp
```
```{r}
#Let's remove the elements from the "gene" vector that aren't in both datasets. Or let's create a new vector containing only the elements common to both datasets:
common_genes=c()
for (i in 1:length(colnames(new_prism.achilles)))
{
  if(colnames(new_prism.achilles)[i] %in% colnames(new_prism.exp) == "TRUE")
  {
    common_genes[i] = colnames(new_prism.achilles)[i]
  }
}
length(common_genes)
sum(is.na(common_genes)) #okay perfect, so the genes which aren't common to both datasets have been set to NA
```
```{r}
#Let's remove these NAs from the common_genes vector:
common_genes_wona = common_genes[complete.cases(common_genes)]
length(common_genes_wona)

```
```{r}
#Let's do the correlation now between the achilles and the expression scores:
cor_ach_exp = c()
for ( i in 1:length(common_genes_wona))
{
  cor_ach_exp[i] = cor(new_prism.achilles_wona[,common_genes_wona[i]], new_prism.exp_wona[,common_genes_wona[i]])
}
cor_ach_exp
#it shows NAs because we only replaced the NAs for the first column
```

```{r}
genes_ach=colnames(new_prism.achilles)
```


```{r}
#Let's remove the NAs from all columns
#First for new_prism.achilles:

for (i in 1:length(genes_ach))
{
  new_prism.achilles_wona[,genes_ach[i]][which(is.na(new_prism.achilles[,genes_ach[i]]))] = mean(new_prism.achilles[,genes_ach[i]], na.rm=TRUE)
}

```

```{r}
#And now for new_prism.exp:

genes_exp=colnames(new_prism.exp)
for (i in 1:length(genes_exp))
{
  new_prism.exp_wona[,genes_exp[i]][which(is.na(new_prism.exp[,genes_exp[i]]))] = mean(new_prism.exp[,genes_exp[i]], na.rm=TRUE)
}

```

```{r}
#Let's do the correlation between the Achilles and expression scores for each cell line now:

cor_ach_exp = c()
for ( i in 1:length(common_genes_wona))
{
  cor_ach_exp[i] = cor(new_prism.achilles_wona[,common_genes_wona[i]], new_prism.exp_wona[,common_genes_wona[i]])
}
cor_ach_exp
#What does this tell us?
#This tells us whether, upon a specific gene KO, the differences in cell proliferation are consistent with the initial differences in expression of that gene
#We get this correlation score for 17767 genes

```

```{r}
mean(cor_ach_exp, na.rm=TRUE)
#is close to zero
```
```{r}
plot(cor_ach_exp, ylab="Achilles-Expression Correlation", xlab="Genes") + axis(1,at=1:length(common_genes_wona), labels=common_genes_wona, las=2)
#how to set graph size so that labels fit on the screen at their respective places?
```

```{r}
#select the values under -0.6. These are the genes where cell proliferation strongly correlates with gene expression (negative because in the achilles dataset the smaller a value is, the more relevant it is to cell proliferation)
which(cor_ach_exp < -0.6)
common_genes_wona[which(cor_ach_exp < -0.6)]
#=> when KOd, these gene inhibit cell proliferation. Between cell lines, the differences in cell proliferation are consistent with the differences in cell expression=> we can say that the expression of these genes has a strong impact on cell proliferation
```
```{r}
print("=====ACHILLES=======")
mean(new_prism.achilles$HNF1B, na.rm=TRUE)
mean(new_prism.achilles$SOX10, na.rm=TRUE)
mean(new_prism.achilles$TP63, na.rm=TRUE)

print("=====EXPRESSION=====")
mean(new_prism.exp$HNF1B, na.rm=TRUE)
mean(new_prism.exp$SOX10, na.rm=TRUE)
mean(new_prism.exp$TP63, na.rm=TRUE)

print("=====CORRELATION====")
cor_ach_exp[which(common_genes_wona=="SOX10")]
cor_ach_exp[which(common_genes_wona=="HNF1B")]
cor_ach_exp[which(common_genes_wona=="TP63")]
```
SOX10 + => proliferation + ==>> SOX10 KO = prolif -  & in cancer: SOX10 expr UP
HNF1B + => proliferation - ==>> HNF1B KO = prolif +   & in cancer:  HNF1B expr DOWN
TP63 + => proliferation +  ==>> TP63 KO = prolif -    & in cancer: TP63 expr UP


###Information on these genes:
###1. SOX10
Wikipedia: This gene encodes a member of the SOX (SRY-related HMG-box) family of transcription factors involved in the regulation of embryonic development and determination of cell fate. The encoded protein acts as a transcriptional activator after forming a protein complex with other proteins. This protein acts as a nucleocytoplasmic shuttle protein and is important for neural crest and peripheral nervous system development.[8]

#SOX10 ablation arrests the cell cycle, induces senescence and suppresses melanomagenesis
Cronin JC, Watkins-Chow DE, Incao A, Hasskamp JH, Schönewolf N, Aoude LG, Hayward NK, Bastian BC, Dummer R, Loftus SK, Pavan WJ. SOX10 ablation arrests cell cycle, induces senescence, and suppresses melanomagenesis. Cancer Res. 2013 Sep 15;73(18):5709-18. doi: 10.1158/0008-5472.CAN-12-4620. Epub 2013 Aug 1. PMID: 23913827; PMCID: PMC3803156

###2. HNF1B
Prostate cancer is the most common malignancy in men in developed countries. In previous study, we identified HNF1B (Hepatocyte Nuclear Factor 1β) as a downstream effector of Enhancer of zeste homolog 2 (EZH2). HNF1B suppresses EZH2‐mediated migration of two prostate cancer cell lines via represses the EMT process by inhibiting SLUG expression. Besides, HNF1B expression inhibits cell proliferation through unknown mechanisms. Here, we demonstrated that HNF1B inhibited the proliferation rate of prostate cancer cells. Overexpression of HNF1B in prostate cancer cells led to the arrest of G1 cell cycle and decreased Cyclin D1 expression. In addition, we re‐explored data from ChIP‐sequencing (ChIP‐seq) and RNA‐sequencing (RNA‐seq), and demonstrated that HNF1B repressed Cyclin D1 via direct suppression of SMAD6 expression. We also identified CDKN2A as a HNF1B‐interacting protein that would contribute to HNF1B‐mediated repression of SMAD6 expression. In summary, we provide the novel mechanisms and evidence in support HNF1B as a tumour suppressor gene for prostate cancer.
#HNF1B inhibits cell proliferation via repression of SMAD6 expression in prostate cancer
Lu W, Sun J, Zhou H, Wang F, Zhao C, Li K, Fan C, Ding G, Wang J. HNF1B inhibits cell proliferation via repression of SMAD6 expression in prostate cancer. J Cell Mol Med. 2020 Dec;24(24):14539-14548. doi: 10.1111/jcmm.16081. Epub 2020 Nov 10. PMID: 33174391; PMCID: PMC7754016.


###3. TP63
Giant cell tumor of bone (GCT) is a destructive neoplasm of uncertain etiology that affects the epiphyseal ends of long bones in young adults. GCT stromal cells (GCTSCs) are the primary neoplastic cells of this tumor and are the only proliferating cell component in long-term culture, which recruits osteoclast-like giant cells that eventually mediate bone destruction. The oncogenesis of GCT and factors driving the neoplastic stromal cells to proliferate extensively and pause at an early differentiation stage of pre-osteoblast lineage remain unknown. Overexpression of p63 was observed in GCTSCs and there is growing evidence that p63 is involved in oncogenesis through different mechanisms. This study aimed to understand the specific role of p63 in cell proliferation and oncogenesis of GCTSCs. We confirmed p63 expression in the mononuclear cells in GCT by immunohistochemical staining. By real-time PCR analysis, we showed a higher level (>15-fold) of TAp63 expression in GCTSCs compared to that in mesenchymal stem cells. Furthermore, we observed that knockdown of the p63 gene by siRNA transfection greatly reduced cell proliferation and induced cell cycle arrest at S phase in GCTSCs. We found that the mRNA expression of CDC2 and CDC25C was substantially suppressed by p63 knockdown at 24–72 h. Moreover, p63 was found to be recruited on the regulatory regions of CDC2 and CDC25C, which contain p53-responsive elements. In summary, our data suggest that p63 regulates GCTSC proliferation by binding to the CDC2 and CDC25C p53-REs, which may inhibit the p53 tumor suppressor activity and contribute to GCT tumorigenesis.
#p63 regulates cell proliferation and cell cycle progression-associated genes in stromal cells of giant cell tumor of the bone
Lau CP, Ng PK, Li MS, Tsui SK, Huang L, Kumta SM. p63 regulates cell proliferation and cell cycle progression‑associated genes in stromal cells of giant cell tumor of the bone. Int J Oncol. 2013 Feb;42(2):437-43. doi: 10.3892/ijo.2012.1727. Epub 2012 Dec 3. PMID: 23229819; PMCID: PMC3583652.

====> How are these genes expressed in liver cancer?
```{r}
print("=====ACHILLES=======")
mean(new_prism.achilles$SOX10[which(rownames(new_prism.achilles) %in% liver_cancer_cell_lines)], na.rm=TRUE)
mean(new_prism.achilles$HNF1B[which(rownames(new_prism.achilles) %in% liver_cancer_cell_lines)], na.rm=TRUE)
mean(new_prism.achilles$TP63[which(rownames(new_prism.achilles) %in% liver_cancer_cell_lines)], na.rm=TRUE)

print("=====EXPRESSION=====")
mean(liver_cancer_cell_lines_expression$SOX10)
mean(liver_cancer_cell_lines_expression$HNF1B)
mean(liver_cancer_cell_lines_expression$TP63)

print("=====CORRELATION====")
cor(new_prism.achilles_wona$SOX10[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)], new_prism.exp_wona$SOX10[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)])
cor(new_prism.achilles_wona$HNF1B[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)], new_prism.exp_wona$HNF1B[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)])
cor(new_prism.achilles_wona$TP63[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)], new_prism.exp_wona$TP63[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)])


```
```{r}
#computing the correlation between two vectors of unequal length by complementing the missing values by the mean of the vactor's values
x = new_prism.achilles_wona$SOX10[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)]
y = new_prism.exp_wona$SOX10[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)]
if ( length(x) != length(y))
{
  diff = abs(length(x)-length(y))
  if(length(x)>length(y))
  {
    for (j in 1:diff)
    {
      y[length(y)+j] = mean(y, na.rm=TRUE)
    }
  }
  else if(length(y)>length(x))
  {
    for (k in 1:diff)
    {
      x[length(x)+k] = mean(x, na.rm=TRUE)
    }
  }
}
cor(x,y)
```
```{r}
print("=====ACHILLES=======")
mean(new_prism.achilles$SOX10[which(rownames(new_prism.achilles) %in% liver_cancer_cell_lines)], na.rm=TRUE)
mean(new_prism.achilles$HNF1B[which(rownames(new_prism.achilles) %in% liver_cancer_cell_lines)], na.rm=TRUE)
mean(new_prism.achilles$TP63[which(rownames(new_prism.achilles) %in% liver_cancer_cell_lines)], na.rm=TRUE)

print("=====EXPRESSION=====")
mean(liver_cancer_cell_lines_expression$SOX10)
mean(liver_cancer_cell_lines_expression$HNF1B)
mean(liver_cancer_cell_lines_expression$TP63)

print("=====CORRELATION====")
x = new_prism.achilles_wona$SOX10[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)]
y = new_prism.exp_wona$SOX10[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)]
if ( length(x) != length(y))
{
  diff = abs(length(x)-length(y))
  if(length(x)>length(y))
  {
    for (j in 1:diff)
    {
      y[length(y)+j] = mean(y, na.rm=TRUE)
    }
  }
  else if(length(y)>length(x))
  {
    for (k in 1:diff)
    {
      x[length(x)+k] = mean(x, na.rm=TRUE)
    }
  }
}
cor(x,y)

x = new_prism.achilles_wona$HNF1B[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)]
y = new_prism.exp_wona$HNF1B[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)]
if ( length(x) != length(y))
{
  diff = abs(length(x)-length(y))
  if(length(x)>length(y))
  {
    for (j in 1:diff)
    {
      y[length(y)+j] = mean(y, na.rm=TRUE)
    }
  }
  else if(length(y)>length(x))
  {
    for (k in 1:diff)
    {
      x[length(x)+k] = mean(x, na.rm=TRUE)
    }
  }
}
cor(x,y)

x = new_prism.achilles_wona$TP63[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)]
y = new_prism.exp_wona$TP63[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)]
if ( length(x) != length(y))
{
  diff = abs(length(x)-length(y))
  if(length(x)>length(y))
  {
    for (j in 1:diff)
    {
      y[length(y)+j] = mean(y, na.rm=TRUE)
    }
  }
  else if(length(y)>length(x))
  {
    for (k in 1:diff)
    {
      x[length(x)+k] = mean(x, na.rm=TRUE)
    }
  }
}
cor(x,y)

```


```{r}
#create df?
#liver_cancer_cell_lines
#new_prism.achilles$SOX10["ACH-000217"]
#df=new_prism.achilles$SOX10[liver_cancer_cell_lines]
#new_prism.achilles$SOX10
which(rownames(prism.achilles)=="ACH-000217")
prism.achilles$SOX10[54]
which(rownames(new_prism.achilles) == "ACH-000217")
new_prism.achilles$SOX10[77]
new_prism.achilles$A1BG[1]
```
###Now let us see if there is any correlation between the copy numbers of a gene and its expression rate
```{r}
#First, let's order the prism.cnv dataframe so that it:
#i) matches the prism dataset order in rows
#ii) matches the achilles dataset in columns
#copy_prism.cnv = prism.cnv
#order_actual_cnv_rows = rownames (copy_prism.cnv)
#order_target_cnv_rows = rownames(prism)
#new_prism.cnv= copy_prism.cnv[match(order_target_cnv_rows, order_actual_cnv_rows),]
#new_prism.cnv

copy_prism.cnv = prism.cnv
order_actual_cnv_columns = colnames (copy_prism.cnv)
order_target_cnv_columns = colnames(prism.achilles)
#new_prism.cnv= copy_prism.cnv[match(order_target_cnv_columns, order_actual_cnv_columns),]
#new_prism.cnv
#column ordering doesn't work, nevermind. Ask Ana
new_prism.cnv = copy_prism.cnv[,intersect(order_actual_cnv_columns, order_target_cnv_columns)]
new_prism.cnv
```
```{r}
#Now let's calcultate the correlation between the expression rates of the genes in all cell lines and their copy number variations!
#First, let's see which genes are common to the 2 datasets:
common_genes_cnv_exp=c()
for (i in 1:length(colnames(new_prism.exp)))
{
  if(colnames(new_prism.exp)[i] %in% colnames(new_prism.cnv) == "TRUE")
  {
    common_genes_cnv_exp[i] = colnames(new_prism.exp)[i]
  }
}
length(common_genes_cnv_exp)
sum(is.na(common_genes_cnv_exp)) #okay perfect, so the genes which aren't common to both datasets have been set to NA
#But where are 4 values? Ask Ana
```
```{r}
#Let's remove these NAs from the common_genes vector:
common_genes_cnv_exp_wona = common_genes_cnv_exp[complete.cases(common_genes_cnv_exp)]
length(common_genes_cnv_exp_wona)
```
```{r}
#Let's compute the correlation between the gene expression and their copy number variations just like we did it for the expression and KO achilles scores:
cor_exp_cnv= c()
for ( i in 1:length(common_genes_cnv_exp_wona))
{
  cor_exp_cnv[i] = cor(new_prism.exp[,common_genes_cnv_exp_wona[i]], new_prism.cnv[,common_genes_cnv_exp_wona[i]])
}
cor_exp_cnv
#okay, we get NAs, let's see how we solve this problem...
```

```{r}
#Let's remove the NAs:
#For new_prism.cnv, because for new_prism.exp we already did it

new_prism.cnv_wona=new_prism.cnv
genes_cnv=colnames(new_prism.cnv)
for (i in 1:length(genes_cnv))
{
  new_prism.cnv_wona[,genes_cnv[i]][which(is.na(new_prism.cnv[,genes_cnv[i]]))] = mean(new_prism.cnv[,genes_cnv[i]], na.rm=TRUE)
}
```

```{r}
#Let's try again to compute the correlation between exp and cnv:
cor_exp_cnv= c()
for ( i in 1:length(common_genes_cnv_exp_wona))
{
  cor_exp_cnv[i] = cor(new_prism.exp_wona[,common_genes_cnv_exp_wona[i]], new_prism.cnv_wona[,common_genes_cnv_exp_wona[i]])
}
cor_exp_cnv
#okay great! Let's plot it
#> length(cor_exp_cnv)
#[1] 18559
```

```{r}
plot(cor_exp_cnv, ylab="Cnv-Expression Correlation", xlab="Genes") + axis(1,at=1:length(common_genes_wona), labels=common_genes_wona, las=2)
#how to set graph size so that labels fit on the screen at their respective places?
 + abline(h = mean(cor_exp_cnv, na.rm=TRUE), col='red')
#What does the error mean? Ask Ana
```
```{r}
#HEATMAP? 
#heatmap(cor_exp_cnv)
#ok so the argument of a heatmap must be a matrix
#nvm Ana said she looks into that question because I wanted to correlate 2 vectors with each other. Let's see what else we can do
```


```{r}
#PCA
#create a table
#tabel = table(new_prism.achilles_wona[,gene[1]], new_prism.exp_wona[,gene[1]])
#colnames(tabel) = c("achilles", "exp")
vector1 = new_prism.achilles_wona[,gene[1]]
vector2 = new_prism.exp_wona[,gene[1]]
tabel = table(vector1, vector2)
xcor = cor(tabel)
```

```{r}
table(c(1,2,3,4,5), c(6,7,8,9,10))
cor(table(c(1,2,3,4,5), c(6,7,8,9,10)))
as.table(cor(c(1,2,3,4,5), c(6,7,8,9,10)))
#so the first vector is the rows and the second vector is the columns
```

```{r}
#ok, let's see what else we can do, let's categorize the mutations we have
#prism.snv
total_mutation_types = as.data.frame(table(factor(prism.snv$Variant_Classification)))
```

```{r}
#These are all the mutations of the liver cancer cell lines
#which(prism.snv$DepMap_ID %in% liver_cancer_cell_lines)
#Let's see their variant classifications
prism.snv$Variant_Classification[which(prism.snv$DepMap_ID %in% liver_cancer_cell_lines)]
total_mutation_types_liver_cancer = as.data.frame(table(factor(prism.snv$Variant_Classification[which(prism.snv$DepMap_ID %in% liver_cancer_cell_lines)])))
```

```{r}
barplot(table(factor(prism.snv$Variant_Classification)))
barplot(table(factor(prism.snv$Variant_Classification[which(prism.snv$DepMap_ID %in% liver_cancer_cell_lines)])))
```

#The ultimate goal is to create a regression model to predict a drug's efficiency on a cell line. Therefore, we need to know what are the variables that have an impact on a drug's efficiency. These can be the concentration, the genes they target, the expression level of the genes, the mutations, the copy number variations etc.

###Let's start with the gene expression
##We want to calculate the correlation between the drug's efficiency on the cell lines and the expression of the genes that these drugs target. A strong anticorrelation would suggest that the higher the target genes are expressed, the better a drug would inhibit the growth of a cell line

```{r}
#Correlation expression target genes- drug efficiency
#create a data frame with the drug names and their targets
drugs_and_targets = data.frame(rownames(new_prism.treat), new_prism.treat$target)
sum(is.na(drugs_and_targets))
dim(drugs_and_targets)
#so we have a total of 11168 rows, out of which 2264 are NA values. We should have a data frame with 8904 NA-free rows
drugs_and_targets_wona = na.omit(drugs_and_targets)
dim(drugs_and_targets_wona)[1]
#Yes, we got it!
colnames(drugs_and_targets_wona) = c("drug", "target.gene")

```
```{r}
#Now we want to access the expression rate of the gene and the corresponding targeting drug name from this data frame and calculate their expression rates
for (r in 1:dim(drugs_and_targets_wona)[1])
{
  cor(new_prism.exp[,drugs_and_targets_wona$target.gene], prism[,drugs_and_targets_wona$drug])
}
```

```{r}
# it's ok, this expression creates a data frame with the expression values of each targeted gene for each cell line
test=new_prism.exp[,drugs_and_targets_wona$target.gene]
# and this one seems to do the same for the durgs and the prism scores, but let's get rid of the NA values
test2 = prism[,drugs_and_targets_wona$drug]
sum(is.na(test))
sum(is.na(test2))
dim(test)
dim(test2)
#ok, they have the same dimensions, so just replacing the NAs should allow for a correlation
#NOTE: comment on how the replacement of NAs by the mean of the data group influences the correlation values
```
```{r}
expression_scores = test
drugs_sensitivity_scores = test2
#expression_scores[which(is.na(expressionscores))] = mean()

trgt_genes=colnames(expression_scores)
for (i in 1:length(trgt_genes))
{
  expression_scores[,trgt_genes[i]][which(is.na(expression_scores[,trgt_genes[i]]))] = mean(expression_scores[,trgt_genes[i]], na.rm=TRUE)
}

drugs=colnames(drugs_sensitivity_scores)
for (j in 1:length(drugs))
{
  drugs_sensitivity_scores[,drugs[j]][which(is.na(drugs_sensitivity_scores[,drugs[j]]))] = mean(drugs_sensitivity_scores[,drugs[j]], na.rm=TRUE)
}

#we have a problem, the columns with same genes just show the same values - well that is ok because there is only ONE gene that can be targeted multiple times
#but for drugs sensitivity no...
```

```{r}
#Let's try now
cor_exp_prism = c()
for (r in 1:dim(drugs_and_targets_wona)[1])
{
  cor_exp_prism[r] = cor(expression_scores[,r],drugs_sensitivity_scores[,r])
}
```
```{r}
plot(cor_exp_prism) + abline(h = mean(cor_exp_prism, na.rm=TRUE), col='red')
mean(cor_exp_prism, na.rm=TRUE)
#okay, this can't be... let's remove the NA lines instead of setting them to the mean
```

```{r}
expression_scores_na.rm = na.omit(test)
#na.omit() only omits the rows, so the number of columns should remain the same
drugs_sensitivity_scores_na.rm = na.omit(test2)
#okay, here we have a problem because apparently every row had NAs...
#the cor.test() function removes NAs and only accepts vectors as input! Perfect!!!
```

```{r}
expression_scores_wna = test
drugs_sensitivity_scores_wna = test2
cor_exp_prism2 = c()

for (r in 1:dim(drugs_and_targets_wona)[1])
{
  #cor_exp_prism[r] = cor.test(expression_scores_wna[,r], drugs_sensitivity_scores_wna[,r])$estimate
  if(sum(is.na(drugs_sensitivity_scores_wna[,r])) == 481)
    next
  cor_exp_prism2[r] = cor.test(drugs_sensitivity_scores_wna[,r], expression_scores_wna[,r])$estimate
}#okay so they have to be numeric vectors. Let's understand how this function works first...
#okay, seems to have worked...
```

```{r}
#Let's see...
cor_exp_prism2
cor_exp_prism2[633]
#great, the missing values are set to NA and thus the indexation is conserved!
```
```{r}
plot(cor_exp_prism2)
mean(cor_exp_prism2, na.rm=TRUE)
mean(cor_exp_prism, na.rm=TRUE)
#ok it's a bit higher than with the mean replacing the NA values, but still low...
```
```{r}
#is there anything relevant at all here?
#which(abs(cor_exp_prism2) > 0.2 )
#which(abs(cor_exp_prism2) > 0.3 )
drugs_and_targets_wona[which(abs(cor_exp_prism2) > 0.2 ),]


```


```{r}
#why is drugs_sensitivity_scores not a numeric vector???
#clasa = c()
#for( i in 1:dim(drugs_and_targets_wona)[1])
#{
#  clasa[i] = class(drugs_sensitivity_scores_wna[,i])
#}
#clasa == "numeric"
# aaa we have some NA columns!
sum(is.na(drugs_sensitivity_scores_wna[,633]))
#yep, all of them are NAs...
```


```{r}
cor.test(x=expression_scores_wna[,1], y=drugs_sensitivity_scores_wna[,1])
names(cor.test(x=expression_scores_wna[,1], y=drugs_sensitivity_scores_wna[,1]))
cor.test(x=expression_scores_wna[,1], y=drugs_sensitivity_scores_wna[,1])$estimate
```
```{r}
#Okay so result:
#These are the drugs and their target genes that show a somewhat relevant corelation ("is the drug more efficient when the target gene is over -expressed?")
#22 total pairs, 11 are above 0.2, 11 are below -0.2.

drugs_and_targets_wona[which(abs(cor_exp_prism2) > 0.2 ),]
```




```{r}
#Let's check the correlation between the expression of a gene and the sensitivity of the drugs
cor_indivgen_prism = c()
for( i in 1:length(colnames(new_prism.exp_wona)))
{
  for( j in 1:length(colnames(prism)))
  {
    cor_indivgen_prism[i] = cor(new_prism.exp_wona[,i], prism[,j])
  }
}
cor_indivgen_prism
```
```{r}
#the variation of the drug sensitivity
plot(apply(prism,2,var,na.rm=TRUE))
prism[,which(apply(prism,2,var,na.rm=TRUE)>3)]
```

```{r}
#the variation of gene expression
plot(apply(new_prism.exp,2,var,na.rm=TRUE))
new_prism.exp[,which(apply(new_prism.exp,2,var,na.rm=TRUE)>10)]
```

#What are the genes that hold the most mutations in the dataset? (Whihc genes are most frequently mutated?) And in liver cancer?
#which cell line has the most mutations?
#which gene is most frequently mutated across all cell lines?
```{r}
length(unique(prism.snv$DepMap_ID))
#ok, so all cell lines have mutations
length(table(prism.snv$DepMap_ID)[which(table(prism.snv$DepMap_ID)!=0)])

```
```{r}
#which cell line has the most mutations?
cl_most_mutations = as.data.frame(sort(table(prism.snv$DepMap_ID), decreasing = TRUE))
cl_most_mutations

```
```{r}
#which liver cancer cell lines have the most mutations?
which(sort(table(liver_cancer_cell_lines_mutations$DepMap_ID), decreasing=TRUE)!=0)
cl_liver_most_mutations = as.data.frame(sort(table(liver_cancer_cell_lines_mutations$DepMap_ID), decreasing=TRUE))
#liver_cancer_cell_lines_mutations[which(sort(table(liver_cancer_cell_lines_mutations$DepMap_ID), decreasing=TRUE)!=0)]
cl_liver_most_mutations
```
```{r}
#length(prism.snv$Hugo_Symbol) this is 452695
#length(unique(prism.snv$Hugo_Symbol)) this is 19318
#so there must be 433377 repetitions
#sort(table(unique(prism.snv$Hugo_Symbol)), decreasing = TRUE)
#table(unique(prism.snv$Hugo_Symbol))
#library('plyr')
#xxd = count(unique(prism.snv$Hugo_Symbol))
#length(xxd$freq)
#of course the frequencies are 1 !!! You have to apply the table() function on the vector with repetitions, not on the unique one! :)))
#table(prism.snv$Hugo_Symbol)
#table(prism.snv$Hugo_Symbol)["TP53"]
#Yessss! It works!
#=> now we get the genes that are most mutated in the dataset:
#mutated_genes = sort(table(prism.snv$Hugo_Symbol), decreasing = TRUE)
#length(mutated_genes) this is 19541
#sum(mutated_genes == 0) this is 223
#19541 - 223 = 19318, which is the length of the unique(blablabla)
#so we have to get rid of the genes with 0 values:
mutated_genes = sort(table(prism.snv$Hugo_Symbol), decreasing = TRUE)[which(sort(table(prism.snv$Hugo_Symbol), decreasing = TRUE)!=0)]
#length(mutated_genes) this is 19318
#Yesss, it works!
mutated_genes
```
```{r}
# And now, we get the genes that are most mutated in our specific liver cancer data set:
#sort(table(liver_cancer_cell_lines_mutations$Hugo_Symbol), decreasing = TRUE)
#length(unique(liver_cancer_cell_lines_mutations$Hugo_Symbol)) this is 487
#length(liver_cancer_cell_lines_mutations$Hugo_Symbol) this is 498
#sum(table(liver_cancer_cell_lines_mutations$Hugo_Symbol)>1) this is 10
liver_mutated_genes = sort(table(liver_cancer_cell_lines_mutations$Hugo_Symbol), decreasing=TRUE)[which(sort(table(liver_cancer_cell_lines_mutations$Hugo_Symbol), decreasing = TRUE)!=0)]
liver_mutated_genes
#length(liver_mutated_genes) this is 487
```

```{r}
#Now let's visualize the data and plot the distributions of the mutations of the genes in each case we calculated:
barplot(liver_mutated_genes)
#plot(liver_mutated_genes)
#hist(liver_mutated_genes)
barplot(mutated_genes)
#plot(mutated_genes)
#hist(mutated_genes)
```
#The gene TTN appears to have a significant role in the transformation of these cells. Let's find out more about it...
TTN codes for Titin (large protein, skeleton muscle, sarcomeres, heart etc), is often mutated in liver cancer 
#This article is interesting because of the used methods!

Shen J, Qi L, Zou Z, Du J, Kong W, Zhao L, Wei J, Lin L, Ren M, Liu B. Identification of a novel gene signature for the prediction of recurrence in HCC patients by machine learning of genome-wide databases. Sci Rep. 2020 Mar 10;10(1):4435. doi: 10.1038/s41598-020-61298-3. PMID: 32157118; PMCID: PMC7064516.



```{r}
#Are these mutations relevant in the context of drug sensitivity? Let's see...
#we look for the cell lines bearing these mutations and we see their prism scores
#head(mutated_genes)
#These are the most mutated genes in the data set of the cell lines
#We want to see if the cell lines with mutations in these genes are more susceptible to drug treatment than those without. To see if the difference is significant, we will perform a T-TEST!

#These are all the cell lines with a tp53 mutation
#prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="TP53")]

#These are the prism scores of all the cell lines with a tp53 mutation
#prism[prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="TP53")],]

#Let's calculate their mean values
#apply(prism[prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="TP53")],],1,mean,na.rm=TRUE)
#Now the mean of the means:
#mean(apply(prism[prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="TP53")],],1,mean,na.rm=TRUE), na.rm=TRUE)
#var(apply(prism[prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="TP53")],],1,mean,na.rm=TRUE), na.rm=TRUE)
mean(apply(prism[unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="TP53")]),],1,mean,na.rm=TRUE), na.rm=TRUE)
var(apply(prism[unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="TP53")]),],1,mean,na.rm=TRUE), na.rm=TRUE)
```
```{r}
#What is the mean of the means of all cell lines?
#mean(apply(prism,1,mean,na.rm=TRUE),na.rm=TRUE)
#var(apply(prism,1,mean,na.rm=TRUE),na.rm=TRUE)

#What is the mean of the means of all cell lines without the tp53 ones?
#mean(apply(prism[prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol!="TP53")],],1,mean,na.rm=TRUE), na.rm=TRUE)
#var(apply(prism[prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol!="TP53")],],1,mean,na.rm=TRUE), na.rm=TRUE)
```
Hi Ana!
The analysis which checks the correlation between the expression levels of specific target genes and the sensitivity of cell lines to drugs targeting that specific gene goes from line 719 to line 860. I wonder, why the overall correlation is very close to 0 and what can I do to show the actual connection between the two, as we discussed in our meeting on Wednesday (the idea was that by checking the correlation, I might miss another connection that is not expressed through the correlation). Could you please take a look at it when you find some moments?

To access the object new_prism.treat, please run this:
order_actual = rownames (prism.treat)
order_target = colnames(prism)
new_prism.treat= prism.treat[match(order_target, order_actual),]
new_prism.treat

To access the object new_prism.exp, please run this:
copy_prism.exp = prism.exp
order_actual_exp = rownames (copy_prism.exp)
order_target_exp = rownames(prism)
new_prism.exp= copy_prism.exp[match(order_target_exp, order_actual_exp),]
new_prism.exp

All the other variables are declared inside these lines. Thank you lots and have a nice week-end!
Robert ;)

```{r}
#What is the mean of the means of all cell lines without the tp53 ones?
#mean(apply(prism[prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol!="TP53")],],1,mean,na.rm=TRUE), na.rm=TRUE)
#var(apply(prism[prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol!="TP53")],],1,mean,na.rm=TRUE), na.rm=TRUE)

#unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol!="TP53")])
#ok, that's why it was too big... the "alocated" space was being exceeded
mean(apply(prism[unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol!="TP53")]),],1,mean,na.rm=TRUE), na.rm=TRUE)
var(apply(prism[unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol!="TP53")]),],1,mean,na.rm=TRUE), na.rm=TRUE)
```
```{r}
#Let's perform a T-Test now
#?t.test()
t.test(mean_values_tp53, alternative="greater", mu=mean_all_wo_tp53)
t.test(mean_values_tp53, alternative="less", mu=mean_all_wo_tp53)
# => the difference doesn't seem to be significant at all here...
```

```{r}
mean_values_tp53 = apply(prism[unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="TP53")]),],1,mean,na.rm=TRUE)
#mean_tp53= mean(apply(prism[unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="TP53")]),],1,mean,na.rm=TRUE), na.rm=TRUE)
#mean_all_wo_tp53=mean(apply(prism[unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol!="TP53")]),],1,mean,na.rm=TRUE), na.rm=TRUE)
```

```{r}
#What is the general susceptibility of the cell to drugs? What value approx.?
#What is the mean of the means of all cell lines?
#mean(apply(prism,1,mean,na.rm=TRUE),na.rm=TRUE)
#var(apply(prism,1,mean,na.rm=TRUE),na.rm=TRUE)
#Does this answer the question? Check later...
```

```{r}
#Let's check the mean of all mutated genes above:
head(mutated_genes)
mean_ttn= mean(apply(prism[unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="TTN")]),],1,mean,na.rm=TRUE), na.rm=TRUE)
mean_muc16= mean(apply(prism[unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="MUC16")]),],1,mean,na.rm=TRUE), na.rm=TRUE)
mean_obscn= mean(apply(prism[unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="OBSCN")]),],1,mean,na.rm=TRUE), na.rm=TRUE)
mean_ryr2= mean(apply(prism[unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="RYR2")]),],1,mean,na.rm=TRUE), na.rm=TRUE)
mean_lrp1b= mean(apply(prism[unique(prism.snv$DepMap_ID[which(prism.snv$Hugo_Symbol=="LRP1B")]),],1,mean,na.rm=TRUE), na.rm=TRUE)
```
```{r}
print("TTN")
mean_ttn
print("MUC16")
mean_muc16
print("TP53")
mean_tp53
print("OBSCN")
mean_obscn
print("RYR2")
mean_ryr2
print("LRP1B")
mean_lrp1b
#pretty comparable...
```
```{r}
means_genes_mutations = c(mean_ttn,mean_muc16,mean_tp53,mean_obscn, mean_ryr2, mean_lrp1b)
hist(means_genes_mutations)
plot(means_genes_mutations, xlab=names(head(mutated_genes)))
#create a loop to store the means of all genes? maybe you can find something interesting there...
```
#Why doesn't this have any effect??? Try looking at drugs which target these genes that are mutated just like you did for achilles and expression!

```{r}
#correlation between drugs targeting these genes and the mutations
which(new_prism.treat$target == "TTN")
which(new_prism.treat$target == "MUC16")
which(new_prism.treat$target == "TP53")
which(new_prism.treat$target == "OBSCN")
which(new_prism.treat$target == "RYR2")
which(new_prism.treat$target == "LRP1B")
#which(new_prism.treat$target == "MAP2K1")
#=> there are no drugs that target these genes...
```
```{r}
#ok, let's look at their achilles scores:
#new_prism.achilles[,"TTN"]
mean(new_prism.achilles[,"TTN"],na.rm=TRUE)
var(new_prism.achilles[,"TTN"],na.rm=TRUE)

mean(new_prism.achilles[,"MUC16"],na.rm=TRUE)
var(new_prism.achilles[,"MUC16"],na.rm=TRUE)

mean(new_prism.achilles[,"TP53"],na.rm=TRUE)
var(new_prism.achilles[,"TP53"],na.rm=TRUE)

mean(new_prism.achilles[,"OBSCN"],na.rm=TRUE)
var(new_prism.achilles[,"OBSCN"],na.rm=TRUE)

mean(new_prism.achilles[,"RYR2"],na.rm=TRUE)
var(new_prism.achilles[,"RYR2"],na.rm=TRUE)

mean(new_prism.achilles[,"LRP1B"],na.rm=TRUE)
var(new_prism.achilles[,"LRP1B"],na.rm=TRUE)

#ok, so here we see some effects...
```
```{r}
mean(apply(new_prism.achilles,2,mean,na.rm=TRUE))
```
```{r}
plot(apply(new_prism.achilles,2,mean,na.rm=TRUE))
#+abline(h=c(mean(new_prism.achilles[,"TTN"],na.rm=TRUE),mean(new_prism.achilles[,"TP53"],na.rm=TRUE)),col=c('red','blue')
#+abline(mean(new_prism.achilles[,"TP53"],na.rm=TRUE),col='blue')
```
```{r}
#These 9 HRR genes are BRCA1, BRCA2, ATM, BRIP1, CHEK2, FANCI, RAD51C, RAD51D, and RAD54L
#https://www.frontiersin.org/articles/10.3389/fonc.2022.709645/full#:~:text=These%209%20HRR%20genes%20are,RAD51C%2C%20RAD51D%2C%20and%20RAD54L.
#Let's see if loss of HRR eficiency (homologuous recombinational repair) is a feature in liver cancer cell lines or in the general tumor dataset
```

```{r}
HRR_genes = c("BRCA1", "BRCA2", "ATM", "BRIP1", "CHEK2", "FANCI", "RAD51C", "RAD51D", "RAD54L")
which(names(mutated_genes) %in% HRR_genes)
mutated_genes[which(names(mutated_genes) %in% HRR_genes)]
#ok, so there is a meaningful amount here
sum(mutated_genes[which(names(mutated_genes) %in% HRR_genes)])/sum(mutated_genes)*100
#so 0.1 of all mutations are related to HRR
```
```{r}
#check this for liver cancer
liver_mutated_genes[which(names(liver_mutated_genes) %in% HRR_genes)]
#ok, so the liver cancer cell lines are not touched by HRR gene mutations at all
names(liver_mutated_genes)
```

