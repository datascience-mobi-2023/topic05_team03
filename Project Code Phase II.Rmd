---
title: "PhaseII"
output: html_document
date: "2023-05-24"
---
```{r}

```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
```{r}
prism
```
```{r}
liver_cancer_cell_lines
```
```{r}
which(rownames(prism.exp) %in% liver_cancer_cell_lines[1] )
```
```{r}
rownames(prism.exp)[467]
```
```{r}
prism.exp[467,]
```
```{r}
which(colnames(prism.exp) == "TP53")
#prism.exp[,8010]
prism.exp[467,8010]
mean(prism.exp[,8010], na.rm=TRUE)
```
```{r}
which(colnames(prism.exp) == "GAPDH") #housekeeping gene!
#prism.exp[,8010]
#prism.exp[467,8010]
#BUB1B, CCNB1, CDK1, CDC25C, CCNA2
```
```{r}
prism.exp[467,3878]
```
```{r}
mean(prism.exp[,3878], na.rm=TRUE)
```
```{r}
which(colnames(prism.exp) == "CDK1")
```
```{r}
prism.exp[467,12537]
mean(prism.exp[,12537], na.rm=TRUE)
```
```{r}
which(new_prism.treat$target == "CCNA2")
#This is the drug that targets the liver cancer relevant gene CCNA2
#concentration?
```
```{r}
#What's its name?
rownames(new_prism.treat[5521,])
```
```{r}
#in prism:
which(colnames(prism) == "BRD-K40331046-305-01-5::0.00061034::HTS002")
```
```{r}
prism[467, 5521]
```
```{r}
prism[467, 5521:5528]
```
```{r}
new_prism.treat[5521:5528,]
```

```{r}
Probetabelle = data.frame(new_prism.treat$target[5521:5528], rownames(new_prism.treat[5521:5528]))
```

```{r}
#now we've set the rownames of the prism.cl dataframe (a copy of it) to match the cell line identificators
#rownames(copy_prism.cl) = prism.cl[,1]
#copy_prism.cl
copy_achilles = prism.achilles
```
```{r}
order_actual_achilles = rownames (copy_achilles)
order_target_achilles = rownames(prism)
new_prism.achilles= copy_achilles[match(order_target_achilles, order_actual_achilles),]
new_prism.achilles
```
```{r}
liver_cancer_cell_lines
```
```{r}
#Which mutations do liver cancer cell lines have?
#prism.snv$DepMap_ID[which(prism.snv$DepMap_ID == liver_cancer_cell_lines)]
liver_cancer_cell_lines_mutations = prism.snv[which(prism.snv$DepMap_ID == liver_cancer_cell_lines),]

```
```{r}
#length(unique(liver_cancer_cell_lines_mutations$DepMap_ID))
#ok, they are 17, all good
```
```{r}
#goal: see if the mutation show any effect on gene expression
#1. count the total mutations for each cell line and compare with the expression scores

liver_cancer_cell_lines_total_mutation_numbers=c()
for (i in 1:length(liver_cancer_cell_lines))
{

 liver_cancer_cell_lines_total_mutation_numbers[i] =(length(which(liver_cancer_cell_lines_mutations == liver_cancer_cell_lines[i])))
  
}
names(liver_cancer_cell_lines_total_mutation_numbers) = liver_cancer_cell_lines
liver_cancer_cell_lines_total_mutation_numbers
```

```{r}
#re-order prism.exp so that it matches the prism data frame order
copy_prism.exp = prism.exp
order_actual_exp = rownames (copy_prism.exp)
order_target_exp = rownames(prism)
new_prism.exp= copy_prism.exp[match(order_target_exp, order_actual_exp),]
new_prism.exp
```
```{r}
#2. Now let's get the gene expression rates for these liver cancer cell lines
indeces_liver_cancer_cell_lines_in_new_prism.exp = c()
for (i in 1:length(liver_cancer_cell_lines))
{

   indeces_liver_cancer_cell_lines_in_new_prism.exp[i] = which(rownames(new_prism.exp) == liver_cancer_cell_lines[i])
  
}
liver_cancer_cell_lines_expression = new_prism.exp[indeces_liver_cancer_cell_lines_in_new_prism.exp,]
liver_cancer_cell_lines_expression
```

```{r}
#Let's see if there are genes which could bear mutations
```

```{r}
#all mutations of the first liver cancer cell line
liver_cancer_cell_lines_mutations[1:liver_cancer_cell_lines_total_mutation_numbers[1],]
```
```{r}
#I want to plot each gene of the cell line against its expression score
# x-axis = total mutation numbers
# y-axis =gene expression score
# points = genes


#od lass einf 1 plot machen mit expression of jede mutation
#x = liver_cancer_cell_lines_total_mutation_numbers#nein weil wir wollen eine mutation von einem gen in einer zelllinie
x = liver_cancer_cell_lines_mutations[1:liver_cancer_cell_lines_total_mutation_numbers[1],]$Hugo_Symbol
y = liver_cancer_cell_lines_expression[1,which(colnames(liver_cancer_cell_lines_expression)==x)]
plot(x,y)
```
```{r}
x = liver_cancer_cell_lines_mutations[1:liver_cancer_cell_lines_total_mutation_numbers[1],]$Hugo_Symbol
#which(colnames(liver_cancer_cell_lines_expression)==x)
x
colnames(liver_cancer_cell_lines_expression)
which(colnames(liver_cancer_cell_lines_expression)==x)
```
```{r}
indecesblabla=c()
for ( i in 1:length(x))
{
 indecesblabla[i] = which(colnames(liver_cancer_cell_lines_expression)==x[i])
  
}
#get expression of those genes
#plot against genes
```
```{r}
#PCA analysis on liver cancer cell lines - expression
pca = prcomp(liver_cancer_cell_lines_expression)
pca

```
```{r}
#pca2 = princomp(t(liver_cancer_cell_lines_expression))
#pca2
mean(cor(t(liver_cancer_cell_lines_expression)))
pca2$loadings
```

```{r}
pca.var = pca$sdev^2
pca.var.per = round(pca.var/sum(pca.var)*100,1)
pca.var.per
```
```{r}
barplot(pca.var.per, main= "Scree Plot", xlab="Principal Component", ylab="Percent Variation")
```

```{r}
plot(pca$x[,1], pca$x[,2])
```
```{r}
#install.packages("ggplot2")
#library(ggplot2)

```

```{r}
pca.data = data.frame(Sample=rownames(pca$x), X=pca$x[,1], Y=pca$x[,2])
pca.data
```
```{r}
ggplot(data = pca.data, aes(x=X, y=Y, label=Sample)) + geom_text() + xlab(paste("PC1-", pca.var.per[1], "%", sep="")) + ylab(paste("PC2- ", pca.var.per[2], "%", sep="")) + theme_bw() + ggtitle("My PCA Graph")
```
```{r}
loading_scores = pca$rotation[,1]
genes_scores = abs(loading_scores)
genes_scores_ranked = sort(genes_scores, decreasing = TRUE)
top_10_genes = names(genes_scores_ranked[1:10])
top_10_genes
pca$rotation[top_10_genes,1]
```
```{r}
correlation_matrix = cor(liver_cancer_cell_lines_expression)
head(correlation_matrix)
```

```{r}
pca analysis on expression x KO
```
```{r}
#First order them so genes match
which(colnames(new_prism.exp) %in% colnames(new_prism.achilles))
```
```{r}
#now we've set the rownames of the prism.cl dataframe (a copy of it) to match the cell line identificators
#rownames(copy_prism.cl) = prism.cl[,1]
#copy_prism.cl
copy_exp = prism.exp
order_actual_expr = colnames (copy_exp)
order_target_expr = colnames(prism.achilles)
new_prism.exp_x_ach= copy_exp[match(order_target_expr, order_actual_expr),]
new_prism.exp_x_ach
#someohow doesn't work, nevermind
```

```{r}
#let's correlate the cell lines expression with their achilles score
gene=colnames(new_prism.achilles)
for (j in 1:length(gene))
{
  print(cor(new_prism.achilles[gene[j]],new_prism.exp[gene[j]]))
}
  

```
```{r}
gene=colnames(new_prism.achilles)
new_prism.achilles[,gene[1]]
```
```{r}
new_prism.exp[,gene[1]]
```
```{r}
cor(new_prism.achilles[,gene[1]], new_prism.exp[,gene[1]])
```
```{r}
#ok, let's replace the NA values with the mean of the data sets
which(is.na(new_prism.achilles[,gene[1]]))
mean(new_prism.achilles[,gene[1]], na.rm=TRUE)
new_prism.achilles_wona= new_prism.achilles
new_prism.achilles_wona[,gene[1]][which(is.na(new_prism.achilles[,gene[1]]))] = mean(new_prism.achilles[,gene[1]], na.rm=TRUE)
```
```{r}
#now for exp
new_prism.exp_wona= new_prism.exp
new_prism.exp_wona[,gene[1]][which(is.na(new_prism.exp[,gene[1]]))] = mean(new_prism.exp[,gene[1]], na.rm=TRUE)
```
```{r}
#now let's perform the correlation
cor(new_prism.achilles_wona[,gene[1]], new_prism.exp_wona[,gene[1]])
for (i in 1:length(gene))
{
  #cor(new_prism.achilles_wona[,gene[i]], new_prism.exp_wona[,gene[i]])
  print(gene[i])
}
  
  cor(new_prism.achilles_wona[,gene[i]], new_prism.exp_wona[,gene[i]])
#cor(new_prism.achilles_wona[,gene], new_prism.exp_wona[,gene])

```

```{r}
for (i in 1:length(gene))
  {if( is.na(gene[i]) == TRUE)
    {print(gene[i])}
#else
   #{ print("totul ok")}
}
sum(is.na(gene))
```
```{r}
sum(is.na(gene))
length(gene) - sum(colnames(new_prism.achilles) %in% colnames(new_prism.exp)) #so 352 gene from achilles are not in prism.exp
```
```{r}
#Let's remove the elements from the "gene" vector that aren't in both datasets. Or let's create a new vector containing only the elements common to both datasets:
common_genes=c()
for (i in 1:length(colnames(new_prism.achilles)))
{
  if(colnames(new_prism.achilles)[i] %in% colnames(new_prism.exp) == "TRUE")
  {
    common_genes[i] = colnames(new_prism.achilles)[i]
  }
}
length(common_genes)
sum(is.na(common_genes)) #okay perfect, so the genes which aren't common to both datasets have been set to NA
```
```{r}
#Let's remove these NAs from the common_genes vector:
common_genes_wona = common_genes[complete.cases(common_genes)]
length(common_genes_wona)

```
```{r}
#Let's do the correlation now between the achilles and the expression scores:
cor_ach_exp = c()
for ( i in 1:length(common_genes_wona))
{
  cor_ach_exp[i] = cor(new_prism.achilles_wona[,common_genes_wona[i]], new_prism.exp_wona[,common_genes_wona[i]])
}
cor_ach_exp
#it shows NAs because we only replaced the NAs for the first column
```

```{r}
genes_ach=colnames(new_prism.achilles)
```


```{r}
#Let's remove the NAs from all columns
#First for new_prism.achilles:

for (i in 1:length(genes_ach))
{
  new_prism.achilles_wona[,genes_ach[i]][which(is.na(new_prism.achilles[,genes_ach[i]]))] = mean(new_prism.achilles[,genes_ach[i]], na.rm=TRUE)
}

```

```{r}
#And now for new_prism.exp:

genes_exp=colnames(new_prism.exp)
for (i in 1:length(genes_exp))
{
  new_prism.exp_wona[,genes_exp[i]][which(is.na(new_prism.exp[,genes_exp[i]]))] = mean(new_prism.exp[,genes_exp[i]], na.rm=TRUE)
}

```

```{r}
#Let's do the correlation between the Achilles and expression scores for each cell line now:

cor_ach_exp = c()
for ( i in 1:length(common_genes_wona))
{
  cor_ach_exp[i] = cor(new_prism.achilles_wona[,common_genes_wona[i]], new_prism.exp_wona[,common_genes_wona[i]])
}
cor_ach_exp
#What does this tell us?
#This tells us whether, upon a specific gene KO, the differences in cell proliferation are consistent with the initial differences in expression of that gene
#We get this correlation score for 17767 genes

```

```{r}
mean(cor_ach_exp, na.rm=TRUE)
#is close to zero
```
```{r}
plot(cor_ach_exp, ylab="Achilles-Expression Correlation", xlab="Genes") + axis(1,at=1:length(common_genes_wona), labels=common_genes_wona, las=2)
#how to set graph size so that labels fit on the screen at their respective places?
```

```{r}
#select the values under -0.6. These are the genes where cell proliferation strongly correlates with gene expression (negative because in the achilles dataset the smaller a value is, the more relevant it is to cell proliferation)
which(cor_ach_exp < -0.6)
common_genes_wona[which(cor_ach_exp < -0.6)]
#=> when KOd, these gene inhibit cell proliferation. Between cell lines, the differences in cell proliferation are consistent with the differences in cell expression=> we can say that the expression of these genes has a strong impact on cell proliferation
```
```{r}
print("=====ACHILLES=======")
mean(new_prism.achilles$HNF1B, na.rm=TRUE)
mean(new_prism.achilles$SOX10, na.rm=TRUE)
mean(new_prism.achilles$TP63, na.rm=TRUE)

print("=====EXPRESSION=====")
mean(new_prism.exp$HNF1B, na.rm=TRUE)
mean(new_prism.exp$SOX10, na.rm=TRUE)
mean(new_prism.exp$TP63, na.rm=TRUE)

print("=====CORRELATION====")
cor_ach_exp[which(common_genes_wona=="SOX10")]
cor_ach_exp[which(common_genes_wona=="HNF1B")]
cor_ach_exp[which(common_genes_wona=="TP63")]
```
SOX10 + => proliferation + ==>> SOX10 KO = prolif -  & in cancer: SOX10 expr UP
HNF1B + => proliferation - ==>> HNF1B KO = prolif +   & in cancer:  HNF1B expr DOWN
TP63 + => proliferation +  ==>> TP63 KO = prolif -    & in cancer: TP63 expr UP


###Information on these genes:
###1. SOX10
Wikipedia: This gene encodes a member of the SOX (SRY-related HMG-box) family of transcription factors involved in the regulation of embryonic development and determination of cell fate. The encoded protein acts as a transcriptional activator after forming a protein complex with other proteins. This protein acts as a nucleocytoplasmic shuttle protein and is important for neural crest and peripheral nervous system development.[8]

#SOX10 ablation arrests the cell cycle, induces senescence and suppresses melanomagenesis
Cronin JC, Watkins-Chow DE, Incao A, Hasskamp JH, Schönewolf N, Aoude LG, Hayward NK, Bastian BC, Dummer R, Loftus SK, Pavan WJ. SOX10 ablation arrests cell cycle, induces senescence, and suppresses melanomagenesis. Cancer Res. 2013 Sep 15;73(18):5709-18. doi: 10.1158/0008-5472.CAN-12-4620. Epub 2013 Aug 1. PMID: 23913827; PMCID: PMC3803156

###2. HNF1B
Prostate cancer is the most common malignancy in men in developed countries. In previous study, we identified HNF1B (Hepatocyte Nuclear Factor 1β) as a downstream effector of Enhancer of zeste homolog 2 (EZH2). HNF1B suppresses EZH2‐mediated migration of two prostate cancer cell lines via represses the EMT process by inhibiting SLUG expression. Besides, HNF1B expression inhibits cell proliferation through unknown mechanisms. Here, we demonstrated that HNF1B inhibited the proliferation rate of prostate cancer cells. Overexpression of HNF1B in prostate cancer cells led to the arrest of G1 cell cycle and decreased Cyclin D1 expression. In addition, we re‐explored data from ChIP‐sequencing (ChIP‐seq) and RNA‐sequencing (RNA‐seq), and demonstrated that HNF1B repressed Cyclin D1 via direct suppression of SMAD6 expression. We also identified CDKN2A as a HNF1B‐interacting protein that would contribute to HNF1B‐mediated repression of SMAD6 expression. In summary, we provide the novel mechanisms and evidence in support HNF1B as a tumour suppressor gene for prostate cancer.
#HNF1B inhibits cell proliferation via repression of SMAD6 expression in prostate cancer
Lu W, Sun J, Zhou H, Wang F, Zhao C, Li K, Fan C, Ding G, Wang J. HNF1B inhibits cell proliferation via repression of SMAD6 expression in prostate cancer. J Cell Mol Med. 2020 Dec;24(24):14539-14548. doi: 10.1111/jcmm.16081. Epub 2020 Nov 10. PMID: 33174391; PMCID: PMC7754016.


###3. TP63
Giant cell tumor of bone (GCT) is a destructive neoplasm of uncertain etiology that affects the epiphyseal ends of long bones in young adults. GCT stromal cells (GCTSCs) are the primary neoplastic cells of this tumor and are the only proliferating cell component in long-term culture, which recruits osteoclast-like giant cells that eventually mediate bone destruction. The oncogenesis of GCT and factors driving the neoplastic stromal cells to proliferate extensively and pause at an early differentiation stage of pre-osteoblast lineage remain unknown. Overexpression of p63 was observed in GCTSCs and there is growing evidence that p63 is involved in oncogenesis through different mechanisms. This study aimed to understand the specific role of p63 in cell proliferation and oncogenesis of GCTSCs. We confirmed p63 expression in the mononuclear cells in GCT by immunohistochemical staining. By real-time PCR analysis, we showed a higher level (>15-fold) of TAp63 expression in GCTSCs compared to that in mesenchymal stem cells. Furthermore, we observed that knockdown of the p63 gene by siRNA transfection greatly reduced cell proliferation and induced cell cycle arrest at S phase in GCTSCs. We found that the mRNA expression of CDC2 and CDC25C was substantially suppressed by p63 knockdown at 24–72 h. Moreover, p63 was found to be recruited on the regulatory regions of CDC2 and CDC25C, which contain p53-responsive elements. In summary, our data suggest that p63 regulates GCTSC proliferation by binding to the CDC2 and CDC25C p53-REs, which may inhibit the p53 tumor suppressor activity and contribute to GCT tumorigenesis.
#p63 regulates cell proliferation and cell cycle progression-associated genes in stromal cells of giant cell tumor of the bone
Lau CP, Ng PK, Li MS, Tsui SK, Huang L, Kumta SM. p63 regulates cell proliferation and cell cycle progression‑associated genes in stromal cells of giant cell tumor of the bone. Int J Oncol. 2013 Feb;42(2):437-43. doi: 10.3892/ijo.2012.1727. Epub 2012 Dec 3. PMID: 23229819; PMCID: PMC3583652.

====> How are these genes expressed in liver cancer?
```{r}
print("=====ACHILLES=======")
mean(new_prism.achilles$SOX10[which(rownames(new_prism.achilles) %in% liver_cancer_cell_lines)], na.rm=TRUE)
mean(new_prism.achilles$HNF1B[which(rownames(new_prism.achilles) %in% liver_cancer_cell_lines)], na.rm=TRUE)
mean(new_prism.achilles$TP63[which(rownames(new_prism.achilles) %in% liver_cancer_cell_lines)], na.rm=TRUE)

print("=====EXPRESSION=====")
mean(liver_cancer_cell_lines_expression$SOX10)
mean(liver_cancer_cell_lines_expression$HNF1B)
mean(liver_cancer_cell_lines_expression$TP63)

print("=====CORRELATION====")
cor(new_prism.achilles_wona$SOX10[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)], new_prism.exp_wona$SOX10[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)])
cor(new_prism.achilles_wona$HNF1B[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)], new_prism.exp_wona$HNF1B[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)])
cor(new_prism.achilles_wona$TP63[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)], new_prism.exp_wona$TP63[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)])


```
```{r}
#computing the correlation between two vectors of unequal length by complementing the missing values by the mean of the vactor's values
x = new_prism.achilles_wona$SOX10[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)]
y = new_prism.exp_wona$SOX10[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)]
if ( length(x) != length(y))
{
  diff = abs(length(x)-length(y))
  if(length(x)>length(y))
  {
    for (j in 1:diff)
    {
      y[length(y)+j] = mean(y, na.rm=TRUE)
    }
  }
  else if(length(y)>length(x))
  {
    for (k in 1:diff)
    {
      x[length(x)+k] = mean(x, na.rm=TRUE)
    }
  }
}
cor(x,y)
```
```{r}
print("=====ACHILLES=======")
mean(new_prism.achilles$SOX10[which(rownames(new_prism.achilles) %in% liver_cancer_cell_lines)], na.rm=TRUE)
mean(new_prism.achilles$HNF1B[which(rownames(new_prism.achilles) %in% liver_cancer_cell_lines)], na.rm=TRUE)
mean(new_prism.achilles$TP63[which(rownames(new_prism.achilles) %in% liver_cancer_cell_lines)], na.rm=TRUE)

print("=====EXPRESSION=====")
mean(liver_cancer_cell_lines_expression$SOX10)
mean(liver_cancer_cell_lines_expression$HNF1B)
mean(liver_cancer_cell_lines_expression$TP63)

print("=====CORRELATION====")
x = new_prism.achilles_wona$SOX10[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)]
y = new_prism.exp_wona$SOX10[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)]
if ( length(x) != length(y))
{
  diff = abs(length(x)-length(y))
  if(length(x)>length(y))
  {
    for (j in 1:diff)
    {
      y[length(y)+j] = mean(y, na.rm=TRUE)
    }
  }
  else if(length(y)>length(x))
  {
    for (k in 1:diff)
    {
      x[length(x)+k] = mean(x, na.rm=TRUE)
    }
  }
}
cor(x,y)

x = new_prism.achilles_wona$HNF1B[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)]
y = new_prism.exp_wona$HNF1B[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)]
if ( length(x) != length(y))
{
  diff = abs(length(x)-length(y))
  if(length(x)>length(y))
  {
    for (j in 1:diff)
    {
      y[length(y)+j] = mean(y, na.rm=TRUE)
    }
  }
  else if(length(y)>length(x))
  {
    for (k in 1:diff)
    {
      x[length(x)+k] = mean(x, na.rm=TRUE)
    }
  }
}
cor(x,y)

x = new_prism.achilles_wona$TP63[which(rownames(new_prism.achilles_wona) %in% liver_cancer_cell_lines)]
y = new_prism.exp_wona$TP63[which(rownames(new_prism.exp_wona) %in% liver_cancer_cell_lines)]
if ( length(x) != length(y))
{
  diff = abs(length(x)-length(y))
  if(length(x)>length(y))
  {
    for (j in 1:diff)
    {
      y[length(y)+j] = mean(y, na.rm=TRUE)
    }
  }
  else if(length(y)>length(x))
  {
    for (k in 1:diff)
    {
      x[length(x)+k] = mean(x, na.rm=TRUE)
    }
  }
}
cor(x,y)

```


```{r}
#create df?
#liver_cancer_cell_lines
#new_prism.achilles$SOX10["ACH-000217"]
#df=new_prism.achilles$SOX10[liver_cancer_cell_lines]
#new_prism.achilles$SOX10
which(rownames(prism.achilles)=="ACH-000217")
prism.achilles$SOX10[54]
which(rownames(new_prism.achilles) == "ACH-000217")
new_prism.achilles$SOX10[77]
new_prism.achilles$A1BG[1]
```
###Now let us see if there is any correlation between the copy numbers of a gene and its expression rate
```{r}
#First, let's order the prism.cnv dataframe so that it:
#i) matches the prism dataset order in rows
#ii) matches the achilles dataset in columns
copy_prism.cnv = prism.cnv
order_actual_cnv_rows = rownames (copy_prism.cnv)
order_target_cnv_rows = rownames(prism)
new_prism.cnv= copy_prism.cnv[match(order_target_cnv_rows, order_actual_cnv_rows),]
new_prism.cnv

#copy_prism.cnv = prism.cnv
#order_actual_cnv_columns = colnames (copy_prism.cnv)
#order_target_cnv_columns = colnames(prism.exp)
#new_prism.cnv= copy_prism.cnv[match(order_target_cnv_columns, order_actual_cnv_columns),]
#new_prism.cnv
#column ordering doesn't work, nevermind. Ask Ana

```
```{r}
#Now let's calcultate the correlation between the expression rates of the genes in all cell lines and their copy number variations!
#First, let's see which genes are common to the 2 datasets:
common_genes_cnv_exp=c()
for (i in 1:length(colnames(new_prism.exp)))
{
  if(colnames(new_prism.exp)[i] %in% colnames(new_prism.cnv) == "TRUE")
  {
    common_genes_cnv_exp[i] = colnames(new_prism.exp)[i]
  }
}
length(common_genes_cnv_exp)
sum(is.na(common_genes_cnv_exp)) #okay perfect, so the genes which aren't common to both datasets have been set to NA
#But where are 4 values? Ask Ana
```
```{r}
#Let's remove these NAs from the common_genes vector:
common_genes_cnv_exp_wona = common_genes_cnv_exp[complete.cases(common_genes_cnv_exp)]
length(common_genes_cnv_exp_wona)
```
```{r}
#Let's compute the correlation between the gene expression and their copy number variations just like we did it for the expression and KO achilles scores:
cor_exp_cnv= c()
for ( i in 1:length(common_genes_cnv_exp_wona))
{
  cor_exp_cnv[i] = cor(new_prism.exp[,common_genes_cnv_exp_wona[i]], new_prism.cnv[,common_genes_cnv_exp_wona[i]])
}
cor_exp_cnv
#okay, we get NAs, let's see how we solve this problem...
```

```{r}
#Let's remove the NAs:
#For new_prism.cnv, because for new_prism.exp we already did it

new_prism.cnv_wona=new_prism.cnv
genes_cnv=colnames(new_prism.cnv)
for (i in 1:length(genes_cnv))
{
  new_prism.cnv_wona[,genes_cnv[i]][which(is.na(new_prism.cnv[,genes_cnv[i]]))] = mean(new_prism.cnv[,genes_cnv[i]], na.rm=TRUE)
}
```

```{r}
#Let's try again to compute the correlation between exp and cnv:
cor_exp_cnv= c()
for ( i in 1:length(common_genes_cnv_exp_wona))
{
  cor_exp_cnv[i] = cor(new_prism.exp_wona[,common_genes_cnv_exp_wona[i]], new_prism.cnv_wona[,common_genes_cnv_exp_wona[i]])
}
cor_exp_cnv
#okay great! Let's plot it
#> length(cor_exp_cnv)
#[1] 18559
```

```{r}
plot(cor_exp_cnv, ylab="Achilles-Expression Correlation", xlab="Genes") + axis(1,at=1:length(common_genes_wona), labels=common_genes_wona, las=2)
#how to set graph size so that labels fit on the screen at their respective places?
 + abline(h = mean(cor_exp_cnv, na.rm=TRUE), col='red')
#What does the error mean? Ask Ana
```
```{r}
#HEATMAP? 
```


```{r}
#PCA
#create a table
#tabel = table(new_prism.achilles_wona[,gene[1]], new_prism.exp_wona[,gene[1]])
#colnames(tabel) = c("achilles", "exp")
vector1 = new_prism.achilles_wona[,gene[1]]
vector2 = new_prism.exp_wona[,gene[1]]
tabel = table(vector1, vector2)
xcor = cor(tabel)
```

```{r}
table(c(1,2,3,4,5), c(6,7,8,9,10))
cor(table(c(1,2,3,4,5), c(6,7,8,9,10)))
as.table(cor(c(1,2,3,4,5), c(6,7,8,9,10)))
#so the first vector is the rows and the second vector is the columns
```

